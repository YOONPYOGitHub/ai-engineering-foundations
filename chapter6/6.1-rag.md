# 6.1 RAG (Retrieval-Augmented Generation)

## 개요

**RAG (Retrieval-Augmented Generation)**은 외부 정보를 검색(Retrieve)한 후 이를 기반으로 응답을 생성(Generate)하는 패턴입니다. Foundation Model의 Context 한계를 극복하고, 최신 정보를 활용해 더 정확한 응답을 생성할 수 있습니다.

## RAG가 필요한 이유

| 문제 | RAG 해결책 |
|------|-----------|
| Context 길이 제한 | 필요한 정보만 선별적으로 검색 |
| 학습 데이터 기준일 한계 | 실시간 외부 데이터 접근 |
| 도메인 지식 부족 | 전문 문서 DB 연결 |
| Hallucination | 검증된 소스 기반 생성 |
| 비용 문제 | 효율적 Context 사용 |

## RAG 아키텍처

### Two-Step Process

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│   Query     │────▶│  Retriever  │────▶│  Generator  │
└─────────────┘     └──────┬──────┘     └──────┬──────┘
                          │                    │
                    ┌─────▼─────┐              │
                    │  External │              │
                    │   Memory  │              │
                    └───────────┘              ▼
                                        ┌───────────┐
                                        │  Response │
                                        └───────────┘
```

1. **Retrieve**: 쿼리와 관련된 정보를 외부 메모리에서 검색
2. **Generate**: 검색된 정보를 Context에 포함하여 응답 생성

### Retriever의 역할

- 쿼리와 관련성이 높은 문서/청크 식별
- 효율적인 검색으로 지연시간 최소화
- 검색 품질이 전체 시스템 성능 결정

---

## 검색 알고리즘 (Retrieval Algorithms)

### 1. Term-based Retrieval

키워드 매칭 기반의 전통적 검색 방식입니다.

#### TF-IDF (Term Frequency-Inverse Document Frequency)

| 구성요소 | 설명 |
|---------|------|
| **TF** | 문서 내 단어 출현 빈도 |
| **IDF** | 전체 문서에서 단어 희소성 |
| **점수** | TF × IDF |

```
TF-IDF(t,d) = TF(t,d) × log(N / DF(t))
- t: 단어, d: 문서, N: 전체 문서 수
- DF(t): 단어 t를 포함하는 문서 수
```

#### BM25 (Best Matching 25)

TF-IDF의 개선 버전으로, 현재 가장 널리 사용되는 term-based 알고리즘입니다.

**개선점:**
- 문서 길이 정규화
- TF 포화(saturation) 처리
- 파라미터 튜닝 가능 (k1, b)

#### Elasticsearch

분산 검색 엔진으로, BM25를 기본 알고리즘으로 사용합니다.

**특징:**
- 대규모 데이터셋 처리
- 실시간 인덱싱
- 복잡한 쿼리 지원
- 높은 가용성

### 2. Embedding-based Retrieval

의미적 유사성 기반의 벡터 검색 방식입니다.

#### 작동 원리

```
Query ──▶ Embedding Model ──▶ Query Vector
                                    │
                                    ▼
                             Vector Database
                                    │
                                    ▼
                           Similar Documents
```

1. 쿼리와 문서를 동일한 임베딩 공간에 매핑
2. 벡터 간 유사도 계산 (Cosine, Euclidean 등)
3. 가장 유사한 문서 반환

#### Vector Database

임베딩 벡터 저장 및 유사도 검색을 위한 특화 DB입니다.

| 솔루션 | 특징 |
|--------|------|
| **Pinecone** | 관리형 서비스, 쉬운 스케일링 |
| **Weaviate** | 오픈소스, GraphQL 지원 |
| **Milvus** | 오픈소스, 대규모 처리 |
| **Chroma** | 경량, 로컬 개발 친화적 |
| **FAISS** | Meta 개발, 고성능 라이브러리 |
| **pgvector** | PostgreSQL 확장 |

#### ANN (Approximate Nearest Neighbor) 알고리즘

정확도를 약간 희생하고 검색 속도를 획기적으로 향상시킵니다.

| 알고리즘 | 원리 | 장점 | 단점 |
|---------|------|------|------|
| **LSH** | 해시 함수로 유사 벡터 그룹화 | 간단한 구현 | 고차원에서 성능 저하 |
| **HNSW** | 계층적 그래프 탐색 | 높은 정확도, 빠른 검색 | 높은 메모리 사용 |
| **IVF** | 벡터 공간 클러스터링 | 메모리 효율적 | 클러스터 경계 문제 |

### 3. 검색 알고리즘 비교

| 측면 | Term-based | Embedding-based |
|------|------------|-----------------|
| **정확한 키워드 매칭** | ✅ 강점 | ❌ 약함 |
| **의미적 유사성** | ❌ 약함 | ✅ 강점 |
| **동의어/유사어 처리** | ❌ 한계 | ✅ 자동 처리 |
| **구현 복잡도** | 낮음 | 높음 |
| **계산 비용** | 낮음 | 높음 |
| **인프라 요구사항** | 적음 | Vector DB 필요 |

### 4. Hybrid Retrieval

두 방식의 장점을 결합한 하이브리드 접근법입니다.

```python
# Hybrid Retrieval 예시 (개념적)
def hybrid_search(query, alpha=0.5):
    term_results = bm25_search(query)      # Term-based
    vector_results = vector_search(query)   # Embedding-based
    
    # 점수 결합 (alpha로 가중치 조절)
    final_score = alpha * term_score + (1 - alpha) * vector_score
    return ranked_results
```

**결합 전략:**
- **Score Fusion**: 두 점수를 가중 평균
- **Rank Fusion (RRF)**: 순위 기반 결합
- **Cascading**: 한 방식으로 필터 후 다른 방식으로 재순위

---

## 검색 최적화 (Retrieval Optimization)

### 1. Chunking Strategy

문서를 적절한 크기로 분할하는 전략입니다.

| 전략 | 설명 | 장점 | 단점 |
|------|------|------|------|
| **Fixed-size** | 고정 토큰/문자 수 | 구현 간단 | 의미 단위 무시 |
| **Sentence-based** | 문장 단위 분할 | 자연스러운 단위 | 크기 불균일 |
| **Paragraph-based** | 단락 단위 분할 | 문맥 보존 | 너무 길 수 있음 |
| **Semantic** | 의미 변화 기준 분할 | 최적 단위 | 구현 복잡 |
| **Recursive** | 계층적 분할 | 유연함 | 파라미터 튜닝 필요 |

**고려사항:**
- 너무 작은 청크: 문맥 손실
- 너무 큰 청크: 관련 없는 정보 포함
- Overlap: 청크 간 중복으로 문맥 연결

### 2. Reranking

초기 검색 결과를 더 정교한 모델로 재순위화합니다.

```
Query ──▶ Retriever ──▶ Top-K Results ──▶ Reranker ──▶ Final Top-N
          (빠르고 대략적)                  (정교하고 느림)
```

**Reranker 모델:**
- **Cross-Encoder**: Query와 Document를 함께 인코딩
- **ColBERT**: Late Interaction 방식
- **BGE Reranker**: 특화된 Reranking 모델

**장점:**
- 검색 정확도 향상
- 초기 검색의 False Positive 제거

**단점:**
- 추가 지연시간
- 계산 비용 증가

### 3. Query Rewriting

사용자 쿼리를 검색에 최적화된 형태로 변환합니다.

```
원본 쿼리: "왜 내 코드가 안 돌아가지?"
          ↓
변환 쿼리: "Python 런타임 에러 해결 방법 디버깅"
```

**기법:**
- **Query Expansion**: 동의어, 관련 용어 추가
- **Query Decomposition**: 복잡한 쿼리를 단순 쿼리로 분해
- **HyDE (Hypothetical Document Embedding)**: 가상의 답변 생성 후 검색

### 4. Contextual Retrieval

문서와 청크에 추가 컨텍스트를 부여합니다.

**방법:**
- 청크에 문서 제목/메타데이터 추가
- 상위 계층 요약 포함
- LLM으로 청크별 컨텍스트 생성

```
# 원본 청크
"이 함수는 데이터를 처리합니다."

# Contextual 청크
"[문서: API 가이드 v2.0, 섹션: 데이터 처리]
이 함수는 데이터를 처리합니다.
[관련: 입력 검증, 에러 처리]"
```

---

## RAG Beyond Texts

### 1. Multimodal RAG

텍스트 외에 이미지, 비디오, 오디오 등을 검색합니다.

**접근법:**
- **Unified Embedding**: 모든 모달리티를 같은 공간에 임베딩
- **Cross-modal Retrieval**: 텍스트로 이미지 검색 (또는 반대)
- **CLIP 기반**: OpenAI CLIP으로 이미지-텍스트 매칭

### 2. RAG with Tabular Data (Text-to-SQL)

구조화된 데이터베이스에서 정보를 검색합니다.

```
자연어 쿼리: "지난 달 매출 상위 5개 제품은?"
          ↓
SQL 생성: SELECT product_name, SUM(sales) as total
          FROM orders
          WHERE date >= '2024-05-01'
          GROUP BY product_name
          ORDER BY total DESC
          LIMIT 5;
          ↓
결과 반환: [{"product": "A", "sales": 1000}, ...]
```

**챌린지:**
- 스키마 이해
- 복잡한 JOIN 처리
- SQL 문법 정확성

---

## RAG 시스템 평가

### 평가 지표

| 지표 | 설명 |
|------|------|
| **Recall@K** | 상위 K개 결과 중 관련 문서 비율 |
| **Precision@K** | 검색된 K개 중 관련 문서 비율 |
| **MRR** | 첫 관련 문서 순위의 역수 평균 |
| **NDCG** | 순위 가중 관련성 점수 |

### End-to-End 평가

검색과 생성 전체를 평가합니다.

- **Answer Accuracy**: 생성된 답변의 정확성
- **Faithfulness**: 검색 결과에 충실한 답변인지
- **Relevance**: 질문에 관련된 답변인지

---

## 토론 질문

1. **Term-based vs Embedding-based**: 어떤 상황에서 어떤 방식이 더 적합한가?
2. **Chunking 전략**: 도메인에 따라 최적의 청크 크기는 어떻게 결정하는가?
3. **Hybrid 접근**: 두 검색 방식을 결합할 때 가중치는 어떻게 설정하는가?
4. **Multimodal RAG**: 다양한 모달리티를 효과적으로 통합하는 방법은?
5. **비용-품질 Trade-off**: Reranking 추가 비용을 정당화할 수 있는 상황은?
