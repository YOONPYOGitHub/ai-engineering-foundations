# 6.2 Agents

## 개요

**Agent**는 환경(Environment)과 상호작용하며 목표 달성을 위해 자율적으로 작업을 수행하는 시스템입니다. AI 모델을 **Planner**로 활용하여 복잡한 작업을 단계별로 분해하고 실행합니다. RAG가 단일 도구(Retriever)를 사용하는 특수한 경우라면, Agent는 다양한 도구를 조합하여 더 복잡한 작업을 수행할 수 있습니다.

## Agent의 구성 요소

```
┌─────────────────────────────────────────────────────┐
│                    Environment                       │
│  ┌───────┐  ┌───────┐  ┌───────┐  ┌───────┐        │
│  │ Tool1 │  │ Tool2 │  │ Tool3 │  │ Tool4 │  ...   │
│  └───┬───┘  └───┬───┘  └───┬───┘  └───┬───┘        │
│      └──────────┴──────────┴──────────┘            │
│                       ▲                             │
│                       │ Actions                     │
│                       │                             │
│              ┌────────┴────────┐                   │
│              │     Agent       │                   │
│              │   (Planner)     │                   │
│              └────────┬────────┘                   │
│                       │                             │
│                       ▼                             │
│              Observations/Feedback                  │
└─────────────────────────────────────────────────────┘
```

| 구성요소 | 설명 |
|---------|------|
| **Environment** | Agent가 상호작용하는 세계 (API, 웹, 파일시스템 등) |
| **Tools** | Agent가 실행할 수 있는 기능들 |
| **Agent (Planner)** | 목표 달성을 위한 계획 수립 및 실행 결정 |
| **Actions** | Agent가 수행하는 구체적 행동 |
| **Observations** | 행동 결과로 얻는 피드백 |

---

## Tools (도구)

Agent의 능력은 사용 가능한 도구에 의해 결정됩니다.

### 도구의 분류

| 카테고리 | 설명 | 예시 |
|---------|------|------|
| **Knowledge Augmentation** | 정보 검색 및 조회 | 웹 검색, DB 쿼리, 문서 검색 |
| **Capability Extension** | 모델이 못하는 작업 수행 | 코드 실행, 수학 계산, 이미지 생성 |
| **Write Actions** | 외부 상태 변경 | 이메일 전송, 파일 저장, API 호출 |

### 도구 정의 예시

```python
# 도구 정의 (Function/Tool Declaration)
tools = [
    {
        "name": "get_weather",
        "description": "특정 도시의 현재 날씨 정보를 조회합니다",
        "parameters": {
            "type": "object",
            "properties": {
                "city": {
                    "type": "string",
                    "description": "도시 이름 (예: 서울, 뉴욕)"
                },
                "unit": {
                    "type": "string",
                    "enum": ["celsius", "fahrenheit"],
                    "default": "celsius"
                }
            },
            "required": ["city"]
        }
    },
    {
        "name": "send_email",
        "description": "이메일을 전송합니다",
        "parameters": {
            "type": "object",
            "properties": {
                "to": {"type": "string"},
                "subject": {"type": "string"},
                "body": {"type": "string"}
            },
            "required": ["to", "subject", "body"]
        }
    }
]
```

### 도구 선택 고려사항

**도구가 많을수록:**
- ✅ 더 많은 기능 수행 가능
- ❌ 올바른 도구 선택 어려움
- ❌ 도구 설명이 Context 차지
- ❌ 실수 가능성 증가

**도구 선택 가이드:**
1. 필수 도구만 포함 (Ablation study로 검증)
2. 모델이 자주 실수하는 도구는 개선하거나 제거
3. 도구 사용 패턴 분석 (어떤 도구가 많이/적게 사용되는지)
4. 도구 전환 패턴 분석 (Tool Transition)

---

## Planning (계획)

### 계획의 역할

복잡한 작업을 실행 가능한 단계로 분해합니다.

```
사용자 요청: "지난 주 베스트셀러 제품의 가격을 알려줘"

계획 생성:
1. get_time() → 현재 날짜 확인
2. fetch_top_products(start_date, end_date) → 베스트셀러 조회
3. fetch_product_info(product_id) → 제품 정보 조회
4. generate_response() → 응답 생성
```

### Function Calling

모델 API가 제공하는 도구 사용 기능입니다.

```python
# Function Calling 흐름 (개념적)

# 1. 도구 정의
tools = [lbs_to_kg_tool, get_weather_tool, ...]

# 2. 모델 호출 시 도구 지정
response = model.chat(
    messages=[{"role": "user", "content": "40파운드는 몇 킬로그램?"}],
    tools=tools,
    tool_choice="auto"  # auto, required, none
)

# 3. 모델 응답 (도구 호출 결정)
# response.tool_calls = [
#     ToolCall(function=Function(name='lbs_to_kg', arguments='{"lbs":40}'))
# ]

# 4. 도구 실행 및 결과 반환
result = lbs_to_kg(lbs=40)  # 18.14 kg
```

**tool_choice 옵션:**
| 옵션 | 설명 |
|------|------|
| `auto` | 모델이 도구 사용 여부 결정 |
| `required` | 최소 하나의 도구 사용 필수 |
| `none` | 도구 사용 금지 |

### 계획의 세분성 (Planning Granularity)

| 레벨 | 예시 | 장점 | 단점 |
|------|------|------|------|
| **High-level** | "1. 현재 날짜 확인" | 생성 쉬움 | 실행에 번역 필요 |
| **Low-level** | "get_time()" | 바로 실행 가능 | 생성 어려움, 도구 변경에 취약 |

**Hierarchical Planning:**
```
High-level Plan → Mid-level Plan → Low-level Plan → Execution
```

### Control Flow (제어 흐름)

| 유형 | 설명 | 예시 |
|------|------|------|
| **Sequential** | 순차 실행 | A → B → C |
| **Parallel** | 병렬 실행 | A, B, C 동시 |
| **If Statement** | 조건부 분기 | if 조건 then A else B |
| **For Loop** | 반복 실행 | while 조건: A |

```
Sequential:  A ──▶ B ──▶ C

Parallel:    A ──┐
             B ──┼──▶ D
             C ──┘

If:          A ──▶ [조건] ──▶ B
                     └────▶ C

Loop:        A ◀──┐
             │    │
             └────┘ (조건 만족까지)
```

---

## Reflection과 Error Correction

### ReAct (Reasoning + Acting)

사고(Thought)와 행동(Action)을 교차 실행하는 프레임워크입니다.

```
Thought 1: 사용자가 지난 주 베스트셀러를 원함. 먼저 현재 날짜 확인 필요.
Act 1: get_time()
Observation 1: 2024-06-15

Thought 2: 현재 날짜가 6월 15일이므로, 지난 주는 6월 8일-14일.
Act 2: fetch_top_products(start_date="2024-06-08", end_date="2024-06-14")
Observation 2: [{"product_id": 123, "name": "Product A"}, ...]

Thought 3: 제품 정보 확인 완료. 가격 정보를 조회해야 함.
Act 3: fetch_product_info(product_id=123)
Observation 3: {"price": 29900, "currency": "KRW"}

Thought 4: 모든 정보 수집 완료. 응답 생성.
Act 4: Finish["지난 주 베스트셀러는 Product A이며, 가격은 29,900원입니다."]
```

### Reflexion

실패 시 원인을 분석하고 개선하는 프레임워크입니다.

```
시도 1: 코드 생성 → 테스트 실패 (1/3 통과)
         ↓
반성: "음수 배열 케이스를 고려하지 않았음"
         ↓
시도 2: 개선된 코드 생성 → 테스트 성공 (3/3 통과)
```

### Reflection의 적용 시점

1. **쿼리 수신 후**: 요청 실현 가능성 평가
2. **계획 생성 후**: 계획의 타당성 검토
3. **각 실행 단계 후**: 진행 상황 점검
4. **전체 완료 후**: 최종 결과 평가

---

## Agent Failure Modes와 평가

### Planning Failures (계획 실패)

| 실패 유형 | 설명 | 예시 |
|----------|------|------|
| **Invalid Tool** | 존재하지 않는 도구 호출 | `bing_search()` (도구 목록에 없음) |
| **Invalid Parameters** | 잘못된 파라미터 수/타입 | `lbs_to_kg(40, "kg")` (1개만 필요) |
| **Incorrect Parameter Values** | 잘못된 파라미터 값 | `lbs_to_kg(100)` (실제로는 120) |
| **Goal Failure** | 목표 미달성 | 예산 초과 여행 계획 |
| **Reflection Error** | 완료되지 않았는데 완료 주장 | 50명 중 40명만 배정 후 완료 선언 |

### Tool Failures (도구 실패)

| 실패 유형 | 설명 |
|----------|------|
| **Wrong Output** | 도구가 잘못된 결과 반환 |
| **Translation Error** | High-level 계획을 도구 호출로 잘못 변환 |
| **Missing Tool** | 필요한 도구가 없음 |

### 평가 지표

```python
# Planning 평가 지표 예시
metrics = {
    "valid_plan_rate": "생성된 계획 중 유효한 계획 비율",
    "avg_attempts": "유효한 계획 얻기까지 평균 시도 횟수",
    "valid_tool_call_rate": "전체 도구 호출 중 유효한 호출 비율",
    "invalid_tool_rate": "잘못된 도구 호출 비율",
    "invalid_param_rate": "잘못된 파라미터 호출 비율",
    "incorrect_value_rate": "잘못된 값 사용 비율"
}
```

### Efficiency (효율성) 평가

| 지표 | 설명 |
|------|------|
| **Steps per Task** | 작업당 평균 단계 수 |
| **Cost per Task** | 작업당 평균 비용 |
| **Time per Action** | 각 행동의 소요 시간 |
| **Latency** | 전체 작업 완료 시간 |

---

## Agent 개선 전략

### Planning 능력 향상

1. **Better System Prompt**: 더 명확한 지시사항과 예시
2. **Better Tool Descriptions**: 도구와 파라미터에 대한 상세 설명
3. **Simpler Functions**: 복잡한 함수를 단순 함수로 분해
4. **Stronger Model**: 더 강력한 모델 사용
5. **Finetuning**: 계획 생성에 특화된 파인튜닝

### Tool Selection 최적화

```python
# 도구 사용 패턴 분석
def analyze_tool_usage(logs):
    tool_frequency = count_tool_calls(logs)
    tool_errors = count_tool_errors(logs)
    tool_transitions = analyze_transitions(logs)
    
    # 자주 실수하는 도구 식별
    problematic_tools = [t for t in tools if error_rate(t) > threshold]
    
    # 사용되지 않는 도구 식별
    unused_tools = [t for t in tools if frequency(t) == 0]
    
    return insights
```

### 도구 진화 (Tool Evolution)

Agent가 기존 도구를 조합하여 새로운 도구를 생성합니다.

```
기본 도구: get_time(), fetch_products(), filter_by_date()
     ↓
조합 도구: get_weekly_bestsellers()  # 위 3개 조합
     ↓
스킬 라이브러리에 저장 → 재사용
```

**Skill Manager (Voyager 논문):**
- 성공한 작업의 코드를 스킬로 저장
- 새 작업에서 관련 스킬 검색 및 재사용

---

## Agent 프레임워크 평가 기준

| 기준 | 질문 |
|------|------|
| **지원 도구** | 어떤 카테고리의 도구를 지원하는가? |
| **Control Flow** | 어떤 제어 흐름을 지원하는가? (병렬 실행?) |
| **확장성** | 새로운 도구 추가가 쉬운가? |
| **Planner** | 어떤 모델/방식으로 계획을 생성하는가? |
| **안전성** | 위험한 행동을 방지하는 메커니즘이 있는가? |

**주요 프레임워크:**
- **AutoGPT**: 소셜 미디어 API 중심 (Reddit, X, Wikipedia)
- **Composio**: 엔터프라이즈 API 중심 (Google Apps, GitHub, Slack)
- **LangChain Agents**: 다양한 도구 통합
- **CrewAI**: 멀티 에이전트 협업

---

## 토론 질문

1. **Planning vs Execution**: 더 나은 계획 생성과 더 나은 도구 실행, 어디에 투자해야 하는가?
2. **Tool Complexity**: 복잡한 도구 하나 vs 단순한 도구 여러 개, 어떤 접근이 효과적인가?
3. **Reflection 비용**: Reflection으로 인한 추가 비용/지연을 정당화할 수 있는 상황은?
4. **Agent 안전성**: Write Action을 수행하는 Agent의 안전을 어떻게 보장하는가?
5. **Human-in-the-Loop**: Agent의 자율성과 사람의 개입 사이 적절한 균형은?
